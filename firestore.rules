/**
 * This ruleset enforces a strict user-ownership security model for the LensVivid application.
 *
 * Core Philosophy:
 * The primary security goal is to isolate user-specific data, ensuring that a user can only ever access
 * their own information. Publicly accessible data is explicitly segregated into its own top-level collection.
 * This approach enhances security, performance, and simplifies the rules logic.
 *
 * Data Structure:
 * All private user data, including profiles, payment cards, and purchase history, is nested
 * within a user-specific document tree: /users/{userId}/... Access to this tree is controlled
 * by matching the authenticated user's ID with the {userId} in the path. Publicly browsable
 * content, like photography services, is stored in a separate top-level collection, /photographyServices.
 *
 * Key Security Decisions:
 * - User Isolation: Users can only read and write data within their own /users/{userId} path.
 * - No User Listing: It is not possible to list all users in the system.
 * - Public Read, Restricted Writes: The /photographyServices collection is readable by anyone,
 *   including unauthenticated users, to allow for browsing. However, writes are currently disabled
 *   pending the addition of an ownership field (e.g., 'authorId') to the data model to identify the creator.
 * - Relational Integrity: On creation, documents within a user's tree (e.g., a payment card) must
 *   contain a 'userId' field that matches the {userId} from the path. This ownership link is immutable
 *   and cannot be changed on update.
 *
 * Denormalization for Authorization:
 * This ruleset relies on path-based authorization by storing all of a user's private data under a
 * path containing their unique user ID (e.g., /users/{userId}/purchases/{purchaseId}). This avoids
 * slow and costly `get()` calls to other documents for authorization checks. The user's ID in the
 * path is the sole source of truth for ownership.
 *
 * Structural Segregation:
 * The data model separates private and public data into different top-level collections.
 * - /users/{userId}/... contains private, user-owned documents.
 * - /photographyServices contains public documents that are safe to list for all clients.
 * This structure is more secure and performant than using a single collection with a boolean 'isPublic' flag.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * isSignedIn
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * isOwner
     * Checks if the authenticated user's ID matches the provided userId.
     * This is the primary function for enforcing user-ownership rules.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * isExistingOwner
     * Checks if the document exists and if the authenticated user is the owner.
     * Used for all update and delete operations to ensure stateful integrity.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * isCreatingOwnValidProfile
     * Validates that a user is creating their own profile and that the profile document's
     * internal 'id' field correctly matches their authenticated UID.
     */
    function isCreatingOwnValidProfile(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * isUpdatingOwnValidProfile
     * Enforces that the profile's immutable 'id' field is not being changed on update.
     */
    function isUpdatingOwnValidProfile() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * isCreatingOwnValidDocument
     * Validates that a user is creating a document (e.g., PaymentCard, Purchase) within
     * their own data tree and that the document's internal 'userId' field correctly
     * matches their authenticated UID.
     */
    function isCreatingOwnValidDocument(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * isUpdatingOwnValidDocument
     * Enforces that a document's immutable 'userId' field is not being changed on update.
     */
    function isUpdatingOwnValidDocument() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to a user's private profile document.
     * @path /users/{userId}/profiles/{profileId}
     * @allow A signed-in user (auth.uid: 'user_abc') can (create) their own profile at /users/user_abc/profiles/profile_123.
     * @deny A different user (auth.uid: 'user_xyz') is blocked from (get)ting the profile at /users/user_abc/profiles/profile_123.
     * @principle Restricts access to a user's own data tree and validates relational integrity.
     */
    match /users/{userId}/profiles/{profileId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnValidProfile(userId);
      allow update: if isExistingOwner(userId) && isUpdatingOwnValidProfile();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's private payment card information.
     * @path /users/{userId}/paymentCards/{paymentCardId}
     * @allow A signed-in user (auth.uid: 'user_abc') can (list) their own payment cards at /users/user_abc/paymentCards.
     * @deny A different user (auth.uid: 'user_xyz') is blocked from (create)ing a card at /users/user_abc/paymentCards/card_456.
     * @principle Enforces strict document ownership for sensitive financial data.
     */
    match /users/{userId}/paymentCards/{paymentCardId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnValidDocument(userId);
      allow update: if isExistingOwner(userId) && isUpdatingOwnValidDocument();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's private purchase history.
     * @path /users/{userId}/purchases/{purchaseId}
     * @allow A signed-in user (auth.uid: 'user_abc') can (delete) their own purchase record at /users/user_abc/purchases/purchase_789.
     * @deny An anonymous user is blocked from (get)ting any purchase record.
     * @principle Restricts access to a user's own data tree and validates relational integrity.
     */
    match /users/{userId}/purchases/{purchaseId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnValidDocument(userId);
      allow update: if isExistingOwner(userId) && isUpdatingOwnValidDocument();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to publicly available photography services.
     * @path /photographyServices/{serviceId}
     * @allow Any user, including anonymous ones, can (get) or (list) all photography services.
     * @deny Any user, including signed-in ones, is blocked from (create)ing a new service.
     * @principle Allows public read access for browsing but locks down writes for security.
     */
    match /photographyServices/{serviceId} {
      allow get: if true;
      allow list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'PhotographyService' entity is missing an 'ownerId' or 'authorId' field.
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}